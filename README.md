# Aspect Oriented Programming Basics Revision

The purpose of this project is to revisit the Aspect Orient Programming concepts of Spring Boot.

# Motivation 🤔
 
In large software projects, it's common for certain functionalities, such as logging, security, and error handling, to
be repeated in many modules and classes. This can result in a cluttered codebase that's hard to maintain and understand.
AOP offers a way to separate these cross-cutting concerns from the core business logic, so they can be managed
independently. With AOP, developers can create reusable code modules called "aspects" that can be applied to multiple
parts of the system, reducing the amount of code duplication and improving maintainability.

AOP also provides a way to modify the behavior of an application at runtime, which can be useful for debugging and
troubleshooting. Additionally, AOP can help improve the performance of an application by reducing the overhead of
cross-cutting concerns.

Overall, by using AOP, developers can create cleaner, more modular code that's easier to maintain, understand, and
modify. It's a powerful tool that can improve code quality and developer productivity, making it an attractive option
for large-scale software projects.

## What is Aspect Oriented Programming? 🧐

AOP, provides modularity in the same sense as how classes do to Object-Oriented Programming. Its goal is to break the
program down into different parts referred to as concerns.

### What really is a cross-cutting concern?

It is often described as a "concern that is applicable to throughout the application, and it affects the entire
application".

An example of a cross-cutting concern formulates to that of a logger system that is applicable to the entire system and
solely for one part of logic.

### Concepts and Terminology

Before moving forward, let's familiarize ourselves with some common terminology.

- Join Point
    - A point in your application. (e.g. method execution, exception handling, field properties...)

---------------------------------------

- Advice : Code executed at a particular point in the execution program.
    - Action to be taken by the Join Point (What happens _____ my Join Point)
        - Here ____ is:
            - Before Advice : execute before Join Point
            - After Advice: execute after a method has executed. Can be used to perform post-process task such as
              logging, or resource clean up.
            - Around Advice : executes both before and after the method call.
            - After-returning advice : executes after a method has returned a value. Used to perform additional
              processing on the returned value.
            - After-throwing advice : executes after a method has thrown an exception. Can be used to perform additional
              processing, such as logging or retrying the method.

---------------------------------------

- Pointcut : Expression language of AOP that matches Join Points.

---------------------------------------

- Target Object : Object being advised by the Aspect.

---------------------------------------

- Aspect : Class continaing advices, Join Points ...

---------------------------------------

- Interceptor : Aspect that contains only one advice.

---------------------------------------

- AOP Proxy : Used to implement Aspect contracts. An AOP proxy is an object that intercepts method calls and applies the
  Advice supplied by the developer to the target object without modifying its code directly. The proxy can be created
  based on the interface/class of the target object thus allowing the proxy to be used as a replacement for the target
  object without requiring changes to the calling code.

#### Okay, so the AOP class intercepts calls to the target object, but how? I know I said it implements or extends but here's what actually happens.

> ### TLDR;
> The Spring AOP uses Byte Code manipulation to inject the AOP class bytecode before different method calls. Check
> out [Javassist](https://www.javassist.org/) or [ASM](https://asm.ow2.io).
> This is known as Weaving, which can be done at compile-time (faster) or runtime (slower, dynamic).

The AOP proxy doesn't extend the target object directly. Instead, it implements the same interface or extends the same
class as the target object (ALL CLASSES EXTEND GLOBAL OBJECT), and intercepts method calls to the target object by
dynamically generating bytecode at runtime.

The generated bytecode includes the advice associated with the relevant aspect, which is executed before and/or after
the method call on the target object. This allows the AOP proxy to apply cross-cutting concerns to the target object
without modifying its code directly.

In other words, the AOP proxy acts as a wrapper around the target object, intercepting its method calls and applying the
advice associated with the relevant aspect. This enables developers to modularize cross-cutting concerns and apply them
to multiple objects in a consistent way, without the need to modify the target object's code.

## AOP Implementations

There are different AOP implementations.

1. JBoss AOP
2. Spring AOP (What we will be focusing on)
3. AspectJ

These different implementations are almost the same granted some differences in the features the offer.

In this project I make use the Spring AOP annotations and not the xml configuration (can prove to be a barrier to entry
sometimes) .

### AOP Annotations

All of these have been covered above.  
@Aspect  
@PointCut  
@Before  
@After  
@AfterReturning  
@Around  
@AfterThrowing

Each of these annotations, except @Aspect have what is called expressions that they can take ( parameters). They are
formulated as such:

execution: Matches method execution join points.  
within:  Matching constraint within certain packages.  
this:  Matching constaint where bean type is instance of supplied/given type.
target: Matching constraint where target object is an instance of the give type.
args: Matching constraint for join point where the arguments are instances of the given type. 
